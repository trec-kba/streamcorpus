/**
 * generated by Scrooge ${project.version}
 */
package streamcorpus

import com.twitter.scrooge.{
  ThriftException, ThriftStruct, ThriftStructCodec3}
import org.apache.thrift.protocol._
import org.apache.thrift.transport.{TMemoryBuffer, TTransport}
import java.nio.ByteBuffer
import scala.collection.mutable
import scala.collection.{Map, Set}

/**
 * Ratings are buman generated assertions about a entire document's
 * utility for a particular topic or entity in a reference KB.
 */
object Rating extends ThriftStructCodec3[Rating] {
  val Struct = new TStruct("Rating")
  val AnnotatorField = new TField("annotator", TType.STRUCT, 1)
  val TargetField = new TField("target", TType.STRUCT, 2)
  val RelevanceField = new TField("relevance", TType.I16, 3)
  val ContainsMentionField = new TField("contains_mention", TType.BOOL, 4)
  val CommentsField = new TField("comments", TType.STRING, 5)
  val MentionsField = new TField("mentions", TType.LIST, 6)

  /**
   * Checks that all required fields are non-null.
   */
  def validate(_item: Rating) {
  }

  override def encode(_item: Rating, _oproto: TProtocol) { _item.write(_oproto) }
  override def decode(_iprot: TProtocol): Rating = Immutable.decode(_iprot)

  def apply(
    annotator: Annotator,
    target: Target,
    relevance: Option[Short] = None,
    containsMention: Option[Boolean] = None,
    comments: Option[String] = None,
    mentions: Option[Seq[String]] = None
  ): Rating = new Immutable(
    annotator,
    target,
    relevance,
    containsMention,
    comments,
    mentions
  )

  def unapply(_item: Rating): Option[Product6[Annotator, Target, Option[Short], Option[Boolean], Option[String], Option[Seq[String]]]] = Some(_item)

  object Immutable extends ThriftStructCodec3[Rating] {
    override def encode(_item: Rating, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): Rating = {
      var annotator: Annotator = null
      var _got_annotator = false
      var target: Target = null
      var _got_target = false
      var relevance: Short = 0
      var _got_relevance = false
      var containsMention: Boolean = false
      var _got_containsMention = false
      var comments: String = null
      var _got_comments = false
      var mentions: Seq[String] = Seq[String]()
      var _got_mentions = false
      var _done = false
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 => { /* annotator */
              _field.`type` match {
                case TType.STRUCT => {
                  annotator = {
                    streamcorpus.Annotator.decode(_iprot)
                  }
                  _got_annotator = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 2 => { /* target */
              _field.`type` match {
                case TType.STRUCT => {
                  target = {
                    streamcorpus.Target.decode(_iprot)
                  }
                  _got_target = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 3 => { /* relevance */
              _field.`type` match {
                case TType.I16 => {
                  relevance = {
                    _iprot.readI16()
                  }
                  _got_relevance = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 4 => { /* containsMention */
              _field.`type` match {
                case TType.BOOL => {
                  containsMention = {
                    _iprot.readBool()
                  }
                  _got_containsMention = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 5 => { /* comments */
              _field.`type` match {
                case TType.STRING => {
                  comments = {
                    _iprot.readString()
                  }
                  _got_comments = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 6 => { /* mentions */
              _field.`type` match {
                case TType.LIST => {
                  mentions = {
                    val _list = _iprot.readListBegin()
                    if (_list.size == 0) {
                      _iprot.readListEnd()
                      Nil
                    } else {
                      val _rv = new mutable.ArrayBuffer[String](_list.size)
                      var _i = 0
                      while (_i < _list.size) {
                        _rv += {
                            _iprot.readString()
  
                        }
                        _i += 1
                      }
                      _iprot.readListEnd()
                      _rv
                    }
                  }
                  _got_mentions = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case _ =>
              TProtocolUtil.skip(_iprot, _field.`type`)
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
      new Immutable(
        annotator,
        target,
        if (_got_relevance) Some(relevance) else None,
        if (_got_containsMention) Some(containsMention) else None,
        if (_got_comments) Some(comments) else None,
        if (_got_mentions) Some(mentions) else None
      )
    }
  }

  /**
   * The default read-only implementation of Rating.  You typically should not need to
   * directly reference this class; instead, use the Rating.apply method to construct
   * new instances.
   */
  class Immutable(
    val annotator: Annotator,
    val target: Target,
    val relevance: Option[Short] = None,
    val containsMention: Option[Boolean] = None,
    val comments: Option[String] = None,
    val mentions: Option[Seq[String]] = None
  ) extends Rating

  /**
   * This Proxy trait allows you to extend the Rating trait with additional state or
   * behavior and implement the read-only methods from Rating using an underlying
   * instance.
   */
  trait Proxy extends Rating {
    protected def _underlying_Rating: Rating
    def annotator: Annotator = _underlying_Rating.annotator
    def target: Target = _underlying_Rating.target
    def relevance: Option[Short] = _underlying_Rating.relevance
    def containsMention: Option[Boolean] = _underlying_Rating.containsMention
    def comments: Option[String] = _underlying_Rating.comments
    def mentions: Option[Seq[String]] = _underlying_Rating.mentions
  }
}

trait Rating extends ThriftStruct
  with Product6[Annotator, Target, Option[Short], Option[Boolean], Option[String], Option[Seq[String]]]
  with java.io.Serializable
{
  import Rating._

  def withoutPassthroughs(f: TField => Boolean) = this
  def withPassthroughs(pts: TraversableOnce[(TField, TTransport)]) = this

  def annotator: Annotator
  def target: Target
  def relevance: Option[Short]
  def containsMention: Option[Boolean]
  def comments: Option[String]
  def mentions: Option[Seq[String]]

  def _1 = annotator
  def _2 = target
  def _3 = relevance
  def _4 = containsMention
  def _5 = comments
  def _6 = mentions

  override def write(_oprot: TProtocol) {
    Rating.validate(this)
    _oprot.writeStructBegin(Struct)
    if (annotator ne null) {
      val annotator_item = annotator
      _oprot.writeFieldBegin(AnnotatorField)
      annotator_item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (target ne null) {
      val target_item = target
      _oprot.writeFieldBegin(TargetField)
      target_item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (relevance.isDefined) {
      val relevance_item = relevance.get
      _oprot.writeFieldBegin(RelevanceField)
      _oprot.writeI16(relevance_item)
      _oprot.writeFieldEnd()
    }
    if (containsMention.isDefined) {
      val containsMention_item = containsMention.get
      _oprot.writeFieldBegin(ContainsMentionField)
      _oprot.writeBool(containsMention_item)
      _oprot.writeFieldEnd()
    }
    if (comments.isDefined) {
      val comments_item = comments.get
      _oprot.writeFieldBegin(CommentsField)
      _oprot.writeString(comments_item)
      _oprot.writeFieldEnd()
    }
    if (mentions.isDefined) {
      val mentions_item = mentions.get
      _oprot.writeFieldBegin(MentionsField)
      _oprot.writeListBegin(new TList(TType.STRING, mentions_item.size))
      mentions_item.foreach { mentions_item_element =>
        _oprot.writeString(mentions_item_element)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def copy(
    annotator: Annotator = this.annotator, 
    target: Target = this.target, 
    relevance: Option[Short] = this.relevance, 
    containsMention: Option[Boolean] = this.containsMention, 
    comments: Option[String] = this.comments, 
    mentions: Option[Seq[String]] = this.mentions
  ): Rating =
    new Immutable(
      annotator, 
      target, 
      relevance, 
      containsMention, 
      comments, 
      mentions
    )

  override def canEqual(other: Any): Boolean = other.isInstanceOf[Rating]

  override def equals(other: Any): Boolean = _root_.scala.runtime.ScalaRunTime._equals(this, other)

  override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)

  override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)


  override def productArity: Int = 6

  override def productElement(n: Int): Any = n match {
    case 0 => annotator
    case 1 => target
    case 2 => relevance
    case 3 => containsMention
    case 4 => comments
    case 5 => mentions
    case _ => throw new IndexOutOfBoundsException(n.toString)
  }

  override def productPrefix: String = "Rating"
}