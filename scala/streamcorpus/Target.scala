/**
 * generated by Scrooge ${project.version}
 */
package streamcorpus

import com.twitter.scrooge.{
  ThriftException, ThriftStruct, ThriftStructCodec3}
import org.apache.thrift.protocol._
import org.apache.thrift.transport.{TMemoryBuffer, TTransport}
import java.nio.ByteBuffer
import scala.collection.mutable
import scala.collection.{Map, Set}

/**
 * Targets are "informationt targets," such as entities or topics,
 * usually from a knowledge base, such as Wikipedia.
 */
object Target extends ThriftStructCodec3[Target] {
  val Struct = new TStruct("Target")
  val TargetIdField = new TField("target_id", TType.STRING, 1)
  val KbIdField = new TField("kb_id", TType.STRING, 2)
  val KbSnapshotTimeField = new TField("kb_snapshot_time", TType.STRUCT, 3)

  /**
   * Checks that all required fields are non-null.
   */
  def validate(_item: Target) {
  }

  override def encode(_item: Target, _oproto: TProtocol) { _item.write(_oproto) }
  override def decode(_iprot: TProtocol): Target = Immutable.decode(_iprot)

  def apply(
    targetId: String,
    kbId: Option[String] = None,
    kbSnapshotTime: Option[StreamTime] = None
  ): Target = new Immutable(
    targetId,
    kbId,
    kbSnapshotTime
  )

  def unapply(_item: Target): Option[Product3[String, Option[String], Option[StreamTime]]] = Some(_item)

  object Immutable extends ThriftStructCodec3[Target] {
    override def encode(_item: Target, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): Target = {
      var targetId: String = null
      var _got_targetId = false
      var kbId: String = null
      var _got_kbId = false
      var kbSnapshotTime: StreamTime = null
      var _got_kbSnapshotTime = false
      var _done = false
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 => { /* targetId */
              _field.`type` match {
                case TType.STRING => {
                  targetId = {
                    _iprot.readString()
                  }
                  _got_targetId = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 2 => { /* kbId */
              _field.`type` match {
                case TType.STRING => {
                  kbId = {
                    _iprot.readString()
                  }
                  _got_kbId = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 3 => { /* kbSnapshotTime */
              _field.`type` match {
                case TType.STRUCT => {
                  kbSnapshotTime = {
                    streamcorpus.StreamTime.decode(_iprot)
                  }
                  _got_kbSnapshotTime = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case _ =>
              TProtocolUtil.skip(_iprot, _field.`type`)
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
      new Immutable(
        targetId,
        if (_got_kbId) Some(kbId) else None,
        if (_got_kbSnapshotTime) Some(kbSnapshotTime) else None
      )
    }
  }

  /**
   * The default read-only implementation of Target.  You typically should not need to
   * directly reference this class; instead, use the Target.apply method to construct
   * new instances.
   */
  class Immutable(
    val targetId: String,
    val kbId: Option[String] = None,
    val kbSnapshotTime: Option[StreamTime] = None
  ) extends Target

  /**
   * This Proxy trait allows you to extend the Target trait with additional state or
   * behavior and implement the read-only methods from Target using an underlying
   * instance.
   */
  trait Proxy extends Target {
    protected def _underlying_Target: Target
    def targetId: String = _underlying_Target.targetId
    def kbId: Option[String] = _underlying_Target.kbId
    def kbSnapshotTime: Option[StreamTime] = _underlying_Target.kbSnapshotTime
  }
}

trait Target extends ThriftStruct
  with Product3[String, Option[String], Option[StreamTime]]
  with java.io.Serializable
{
  import Target._

  def withoutPassthroughs(f: TField => Boolean) = this
  def withPassthroughs(pts: TraversableOnce[(TField, TTransport)]) = this

  def targetId: String
  def kbId: Option[String]
  def kbSnapshotTime: Option[StreamTime]

  def _1 = targetId
  def _2 = kbId
  def _3 = kbSnapshotTime

  override def write(_oprot: TProtocol) {
    Target.validate(this)
    _oprot.writeStructBegin(Struct)
    if (targetId ne null) {
      val targetId_item = targetId
      _oprot.writeFieldBegin(TargetIdField)
      _oprot.writeString(targetId_item)
      _oprot.writeFieldEnd()
    }
    if (kbId.isDefined) {
      val kbId_item = kbId.get
      _oprot.writeFieldBegin(KbIdField)
      _oprot.writeString(kbId_item)
      _oprot.writeFieldEnd()
    }
    if (kbSnapshotTime.isDefined) {
      val kbSnapshotTime_item = kbSnapshotTime.get
      _oprot.writeFieldBegin(KbSnapshotTimeField)
      kbSnapshotTime_item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def copy(
    targetId: String = this.targetId, 
    kbId: Option[String] = this.kbId, 
    kbSnapshotTime: Option[StreamTime] = this.kbSnapshotTime
  ): Target =
    new Immutable(
      targetId, 
      kbId, 
      kbSnapshotTime
    )

  override def canEqual(other: Any): Boolean = other.isInstanceOf[Target]

  override def equals(other: Any): Boolean = _root_.scala.runtime.ScalaRunTime._equals(this, other)

  override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)

  override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)


  override def productArity: Int = 3

  override def productElement(n: Int): Any = n match {
    case 0 => targetId
    case 1 => kbId
    case 2 => kbSnapshotTime
    case _ => throw new IndexOutOfBoundsException(n.toString)
  }

  override def productPrefix: String = "Target"
}