/**
 * generated by Scrooge ${project.version}
 */
package streamcorpus

import com.twitter.scrooge.{
  ThriftException, ThriftStruct, ThriftStructCodec3}
import org.apache.thrift.protocol._
import org.apache.thrift.transport.{TMemoryBuffer, TTransport}
import java.nio.ByteBuffer
import scala.collection.mutable
import scala.collection.{Map, Set}

/**
 * Labels are human generated assertions about a portion of a document
 * For example, a human author might label their own text by inserting
 * hyperlinks to Wikipedia, or a NIST assessor might record which
 * tokens in a text mention a target entity.
 * 
 * Label instances can be attached in three palces:
 *  -  Token.labels  list
 *  -  Sentence.labels  list
 *  -  ContentItem.labels  map
 */
object Label extends ThriftStructCodec3[Label] {
  val Struct = new TStruct("Label")
  val AnnotatorField = new TField("annotator", TType.STRUCT, 1)
  val TargetField = new TField("target", TType.STRUCT, 2)
  val OffsetsField = new TField("offsets", TType.MAP, 3)

  /**
   * Checks that all required fields are non-null.
   */
  def validate(_item: Label) {
  }

  override def encode(_item: Label, _oproto: TProtocol) { _item.write(_oproto) }
  override def decode(_iprot: TProtocol): Label = Immutable.decode(_iprot)

  def apply(
    annotator: Annotator,
    target: Target,
    offsets: Map[OffsetType, Offset] = Map()
  ): Label = new Immutable(
    annotator,
    target,
    offsets
  )

  def unapply(_item: Label): Option[Product3[Annotator, Target, Map[OffsetType, Offset]]] = Some(_item)

  object Immutable extends ThriftStructCodec3[Label] {
    override def encode(_item: Label, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): Label = {
      var annotator: Annotator = null
      var _got_annotator = false
      var target: Target = null
      var _got_target = false
      var offsets: Map[OffsetType, Offset] = Map()
      var _got_offsets = false
      var _done = false
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 => { /* annotator */
              _field.`type` match {
                case TType.STRUCT => {
                  annotator = {
                    streamcorpus.Annotator.decode(_iprot)
                  }
                  _got_annotator = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 2 => { /* target */
              _field.`type` match {
                case TType.STRUCT => {
                  target = {
                    streamcorpus.Target.decode(_iprot)
                  }
                  _got_target = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 3 => { /* offsets */
              _field.`type` match {
                case TType.MAP => {
                  offsets = {
                    val _map = _iprot.readMapBegin()
                    if (_map.size == 0) {
                      _iprot.readMapEnd()
                      Map.empty[OffsetType, Offset]
                    } else {
                      val _rv = new mutable.HashMap[OffsetType, Offset]
                      var _i = 0
                      while (_i < _map.size) {
                        val _key = {
                            OffsetType(_iprot.readI32())
  
                        }
                        val _value = {
                            Offset.decode(_iprot)
  
                        }
                        _rv(_key) = _value
                        _i += 1
                      }
                      _iprot.readMapEnd()
                      _rv
                    }
                  }
                  _got_offsets = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case _ =>
              TProtocolUtil.skip(_iprot, _field.`type`)
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
      new Immutable(
        annotator,
        target,
        offsets
      )
    }
  }

  /**
   * The default read-only implementation of Label.  You typically should not need to
   * directly reference this class; instead, use the Label.apply method to construct
   * new instances.
   */
  class Immutable(
    val annotator: Annotator,
    val target: Target,
    val offsets: Map[OffsetType, Offset] = Map()
  ) extends Label

  /**
   * This Proxy trait allows you to extend the Label trait with additional state or
   * behavior and implement the read-only methods from Label using an underlying
   * instance.
   */
  trait Proxy extends Label {
    protected def _underlying_Label: Label
    def annotator: Annotator = _underlying_Label.annotator
    def target: Target = _underlying_Label.target
    def offsets: Map[OffsetType, Offset] = _underlying_Label.offsets
  }
}

trait Label extends ThriftStruct
  with Product3[Annotator, Target, Map[OffsetType, Offset]]
  with java.io.Serializable
{
  import Label._

  def withoutPassthroughs(f: TField => Boolean) = this
  def withPassthroughs(pts: TraversableOnce[(TField, TTransport)]) = this

  def annotator: Annotator
  def target: Target
  def offsets: Map[OffsetType, Offset]

  def _1 = annotator
  def _2 = target
  def _3 = offsets

  override def write(_oprot: TProtocol) {
    Label.validate(this)
    _oprot.writeStructBegin(Struct)
    if (annotator ne null) {
      val annotator_item = annotator
      _oprot.writeFieldBegin(AnnotatorField)
      annotator_item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (target ne null) {
      val target_item = target
      _oprot.writeFieldBegin(TargetField)
      target_item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (offsets ne null) {
      val offsets_item = offsets
      _oprot.writeFieldBegin(OffsetsField)
      _oprot.writeMapBegin(new TMap(TType.I32, TType.STRUCT, offsets_item.size))
      offsets_item.foreach { _pair =>
        val offsets_item_key = _pair._1
        val offsets_item_value = _pair._2
        _oprot.writeI32(offsets_item_key.value)
        offsets_item_value.write(_oprot)
      }
      _oprot.writeMapEnd()
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def copy(
    annotator: Annotator = this.annotator, 
    target: Target = this.target, 
    offsets: Map[OffsetType, Offset] = this.offsets
  ): Label =
    new Immutable(
      annotator, 
      target, 
      offsets
    )

  override def canEqual(other: Any): Boolean = other.isInstanceOf[Label]

  override def equals(other: Any): Boolean = _root_.scala.runtime.ScalaRunTime._equals(this, other)

  override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)

  override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)


  override def productArity: Int = 3

  override def productElement(n: Int): Any = n match {
    case 0 => annotator
    case 1 => target
    case 2 => offsets
    case _ => throw new IndexOutOfBoundsException(n.toString)
  }

  override def productPrefix: String = "Label"
}